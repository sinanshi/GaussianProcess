from gp_emulator import GaussianProcess
import gpugp
from numpy import random as random
import numpy as np
import pytest

def rosenrock (x):
    """Test with simulated data generated by Rosenrock function
    see https://www.sfu.ca/~ssurjano/rosen.html
    """
    d = x.size
    xi = x[0 : (d - 1)]
    xnext = x[1 : d ]
    y = sum(100 * (xnext - xi ** 2) ** 2 + (xi - 1) ** 2)
    return y


def test_rosenrock():
    """The values are from the R script from the website"""
    x = np.array([1, 1, 1])
    y = rosenrock(x)
    assert y == 0

    x = np.array([0, 0, 1])
    y = rosenrock(x)
    assert y == 102

    x = np.array([-0.50, -0.50, -0.99, 4.50])
    y = rosenrock(x)
    assert y == pytest.approx(1457.44)

    x = np.array([1., 100, -0.440, -0.999, 23534])
    y = rosenrock(x)
    assert y == pytest.approx(65382088377)

#def test_single_var_gp():
#    size = 100
#    train_x = np.linspace(-1, 1, size)
#    train_y = np.sin(train_x) * 10 + random.uniform(-1e-2, 1e-2, size)
#    train_x = train_x.reshape(size, 1)
#
#    gp = GaussianProcess.GaussianProcess(train_x, train_y)
#    gp.learn_hyperparameters(n_tries=2)
#    pred_mu, pred_var, par_dev = gp.predict(train_x)
#
#    r = (train_y - pred_mu) ** 2
#    assert np.sqrt(r.mean()) < 1e-2



def test_rosenrock_gp():
    pass
#    size = 100
#    d = 10
#    train_x = random.uniform(-5, 10, d * size).reshape(size, d)
#    train_y = np.apply_along_axis(rosenrock, 1, train_x)
##    print(train_y.mean())
##    print(train_y.std())
##    train_y = (train_y - train_y.mean())/ train_y.std() 
##    print(train_y)
#
#    gp = GaussianProcess.GaussianProcess(train_x, train_y)
##    
#    import cProfile, pstats
#    from io import StringIO
#    pr = cProfile.Profile()
#    pr.enable()
#    gp.learn_hyperparameters(n_tries=1)
#    pr.disable()
#    s = StringIO()

#    sortby = 'cumulative'
#    ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
#    ps.print_stats()
#    print(s.getvalue())
#
#
#
#    size = 100
#    target_x = random.uniform(-5, 10, d * size).reshape(size, d)
#    target_y = np.apply_along_axis(rosenrock, 1, target_x)
#
##    target_x = train_x
##    target_y = train_y
#    pred_y, pred_var, par_dev = gp.predict(target_x)
#    print(target_y)
#    print(pred_y)
#    print(np.mean(np.abs((pred_y - target_y) / target_y)))

#def test_gpu():
#    arr = np.array([1,2,2,2, 2, 4], dtype=np.int32)
#    adder = gpuadder.GPUAdder(arr)
#    adder.increment()
#
#    adder.retreive_inplace()
#    results2 = adder.retreive()
#    print(results2)
#def test_rosenrock_gp():


def test_gpu2():
    N = 5
    A = np.eye(N, dtype=np.float32, order="C")
    A[1][0] = 2
    A[2][1] = 2
    A[3][1] = 4
    A[0][0] = 9

    print(A)

    A = np.dot(A, A.T)


    print(A)
#    targets = np.random.rand(N, dtype=np.float32)
    targets = np.ones(N, dtype=np.float32) 
    like=gpugp.pygpulike(A, targets)

    invQ, invQt, logdetQ = like.cholesky()
    L = np.linalg.cholesky(A)
    invL = np.linalg.inv(L)
    print(invQ)
    print(np.linalg.inv(A))
    
    print(np.linalg.inv(L.T).dot(np.linalg.inv(L)))
    print(invQt)
    print(np.dot(invQ, targets))
    
    print(2.0 * np.sum ( np.log ( np.diag ( L ))))
    print(logdetQ)


