from gp_emulator import GaussianProcess
import gpugp
from numpy import random as random
import numpy as np
#import pytest

def rosenrock (x):
    """Test with simulated data generated by Rosenrock function
    see https://www.sfu.ca/~ssurjano/rosen.html
    """
    d = x.size
    xi = x[0 : (d - 1)]
    xnext = x[1 : d ]
    y = sum(100 * (xnext - xi ** 2) ** 2 + (xi - 1) ** 2)
    return y

import time

def test_rosenrock_gp():
    size = 500
    d = 70
    train_x = random.uniform(-5, 10, d * size).reshape(size, d)
    train_y = np.apply_along_axis(rosenrock, 1, train_x)
#    print(train_y.mean())
#    print(train_y.std())
    train_y = (train_y - train_y.mean())/ train_y.std() 
    #    print(train_y)
    

    gp = GaussianProcess.GaussianProcess(train_x, train_y)
    #    
#    import cProfile, pstats
#    from io import StringIO
#    pr = cProfile.Profile()
#    pr.enable()
#    gp.learn_hyperparameters(n_tries=1)
    start = time.time()
    gp.learn_hyperparameters(n_tries=1, gpu=True)
    end = time.time()
    print("GPU time: ")
    print(end - start)
    
    print("CPU time: ")
    start = time.time()
    gp.learn_hyperparameters(n_tries=1, gpu=False)
    end = time.time()
    print(end - start)

    
    
#    print("gpu")
#
#    for i in range(10):
#        gp._set_param  (gp.theta, gpu=True)
#        sg = gp.invQt
#    print(sg[0:10])
#
#    print("cpu")
#
#    for i in range(10):
#        gp._set_params(gp.theta, gpu=False)
#        sc = gp.invQt
#
#    print(sc[0:10])
#

#    gp.learn_hyperparameters(n_tries=1, gpu=True)
#    pr.disable()
#    s = StringIO()

#    sortby = 'cumulative'
#    ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
#    ps.print_stats()
#    print(s.getvalue())



#    size = 100
#    target_x = random.uniform(-5, 10, d * size).reshape(size, d)
#    target_y = np.apply_along_axis(rosenrock, 1, target_x)
#
#    target_x = train_x
#    target_y = train_y
#pred_y, pred_var, par_dev = gp.predict(target_x)
#print(target_y)
#print(pred_y)
#print(np.mean(np.abs((pred_y - target_y) / target_y)))

def test_gpu2():
    N = 500
    A = np.eye(N, dtype=np.float32, order="C")
    A[1][0] = 2
    A[2][1] = 2
    A[3][1] = 4
    A[0][0] = 9

    print(A)

    A = np.dot(A, A.T)


    print(A)
#    targets = np.random.rand(N, dtype=np.float32)
    targets = np.ones(N, dtype=np.float32) 
    like=gpugp.pygpulike(A, targets)

    invQ, invQt, logdetQ = like.cholesky()
    L = np.linalg.cholesky(A)
    invL = np.linalg.inv(L)
    print(invQ)
    print(np.linalg.inv(A))
    
    print(np.linalg.inv(L.T).dot(np.linalg.inv(L)))
    print(invQt)
    print(np.dot(invQ, targets))
    
    print(2.0 * np.sum ( np.log ( np.diag ( L ))))
    print(logdetQ)

if __name__ == "__main__":
    size = 500
    d = 50
    train_x = random.uniform(-5, 10, d * size).reshape(size, d)
    train_y = np.apply_along_axis(rosenrock, 1, train_x)
    train_y = (train_y - train_y.mean())/ train_y.std()


 
    gp = GaussianProcess.GaussianProcess(train_x, train_y)
    theta = np.random.rand(gp.D + 2)

    gp.theta = theta
    
    start = time.time()
    gp._set_params(gp.theta, gpu=False)
    end = time.time()
    
    invQt1 = gp.invQt
    invQ1 = gp.invQ
    Z1 = gp.Z
    Q1=gp.Q
    logdetQ1 = gp.logdetQ
    print("GPU time: ")
    print(end - start)

    gp = GaussianProcess.GaussianProcess(train_x, train_y)
    gp.theta = theta
    print("CPU time: ")
    start = time.time()
    gp._set_params(gp.theta, gpu=True)
    end = time.time()
    print(end - start)
    
    invQt2 = gp.invQt
    invQ2 = gp.invQ
    Z2 = gp.Z
    Q2=gp.Q
    logdetQ2 = gp.logdetQ


    print("invQt")
    print(invQt1 - invQt2)
    print("invQ")
    print(np.max(np.abs(invQ1-invQ2)))
    print("Q")
    print(Q2 - Q1)
    print("Z")
    print(Z2 - Z1)
    print("lgodet")
    print(logdetQ2 - logdetQ1)


